> # Global variables
> sigma <- 1
> max <- 3
> min <- 1
> x <- c(3.08, 0.68, 2.09, 0.87, -0.02, 0.25, 1.98, 1.47, 1.95, 0.99)
> draws <- numeric(20000)
> threshold <- 1.7
> initial_state <- 2
> 
> log_d_norm_unif_post <- function(state) {
+   if (state <= max && state >= min) {
+     result <- 0.0
+     for ( i in 1:length(x) ) {
+       result <- result + -0.5*(((x[i]-state)/sigma)^2)
+     }
+   } else {
+     result <- -Inf
+   }
+   return(result)
+ }
> 
> sample_via_mcmc <- function(step_width) {
+   draws[1] <- initial_state
+   accept <- 0
+   for ( i in 2:length(draws) ) {
+     # g() = uniform distribution centered at draws[i-1], which is symmetric
+     proposal <- draws[i-1] + runif(1,-step_width/2,step_width/2) 
+     # p() = normal uniform posterior
+     log_m_ratio <- log_d_norm_unif_post(proposal) - log_d_norm_unif_post(draws[i-1]) 
+     if ( log(runif(1)) < log_m_ratio ) {
+       draws[i] <- proposal
+       accept <- accept + 1
+     } else {
+       draws[i] <- draws[i-1]
+     }
+   }
+ 
+   # calculate percentile
+ 
+   if (threshold > max(draws))
+     percentile  = 1.0 
+   else if (threshold < min(draws))
+     percentile  = 0.0 
+   else {
+     p1 = 0
+     for ( i in 1:length(draws) ) {
+       if (draws[i] <= threshold)
+         p1 <- p1 + 1
+     }
+     p1 = p1 / length(draws)
+     p2 = 0
+     for ( i in 1:length(draws) ) {
+       if (draws[i] >= threshold)
+         p2 <- p2 + 1
+     }
+     p2 = 1 - p2 / length(draws)
+     avg.p = (p1 + p2) / 2
+     percentile = max(min(avg.p,1),0)
+   }
+ 
+   return(c(accept/length(draws), mean(draws), sqrt(var(draws)), percentile))
+ }
> 
> sample_via_mcmc(0.1)
[1] 0.9640500 1.4678540 0.2536417 0.8082000
> 
